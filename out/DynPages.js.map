{
  "version": 3,
  "sources": ["../dyn/DynAlias.ts", "../dyn/DynStream.ts", "../dyn/DynPlate.ts", "../dyn/DynRecord.ts", "../dyn/DynBind.ts", "../dyn/DynRules.ts", "../dyn/DynPair.ts", "../dyn/DynNode.ts", "../dyn/DynPages.ts"],
  "sourcesContent": [
    "export class DynAlias {\n    static StreamAliases: Map<string, string> = new Map();\n  \n    static FetchOrSetAliasIfApplicable(streamPath: string): string {\n      if (DynAlias.HasAliasInPath(streamPath)) {\n        let alias = '';\n        [streamPath, alias] = DynAlias.ExtractStreamAlias(streamPath);\n        DynAlias.SetStreamAlias(streamPath, alias);\n      }\n      if (DynAlias.HasAlias(streamPath)) {\n        streamPath = DynAlias.GetStreamFromAlias(streamPath);\n      }\n      return streamPath;\n    }\n  \n    static HasAliasInPath(streamPath: string): boolean {\n      return streamPath.includes(' as ');\n    }\n  \n    static HasAlias(alias: string): boolean {\n      return this.StreamAliases.has(alias);\n    }\n  \n    static ExtractStreamAlias(streamPath: string): [string, string] {\n      return streamPath.split(' as ') as [string, string];\n    }\n  \n    static SetStreamAlias(streamPath: string, userAlias: string): void {\n      this.StreamAliases.set(userAlias, streamPath);\n    }\n  \n    static GetStreamFromAlias(userAlias: string): string {\n      const result = this.StreamAliases.get(userAlias);\n      if (!result) {\n        throw new Error(`Alias '${userAlias}' not found`);\n      }\n      return result;\n    }\n  }",
    "import { DynStreamTypes, Type } from './types';\n\nexport class DynStream {\n  static CachedStreams: Map<string, any> = new Map();\n  private Source: string;\n\n  private CurrentType : Type\n\n  constructor(source: string, typeId: DynStreamTypes) {\n    this.CurrentType = this.GetType(typeId);\n    this.Source = source;\n  }\n\n  private Type = (Name: string, Id: DynStreamTypes): Type => ({ Name, Id });\n\n  private GetType(typeId: DynStreamTypes): Type {\n    const foundType = this.StreamTypes.find((type) => type.Id === typeId);\n\n    if (!foundType) {\n      throw new Error('Invalid Dyn Stream. Unknown Type Id was supplied to Dyn stream.');\n    }\n    return foundType;\n  }\n\n  private StreamTypes: Type[] = [\n    this.Type('Record', DynStreamTypes.RECORD),\n    this.Type('Plate', DynStreamTypes.PLATE),\n    this.Type('Dyn', DynStreamTypes.DYN)\n  ];\n\n  private Stream = (): any => DynStream.CachedStreams.get(this.Source);\n\n  private async WaitTillFetched(key: string): Promise<any> {\n    while (true) {\n      const value = DynStream.CachedStreams.get(key);\n      if (value !== 'fetching') {\n        return value;\n      }\n      await new Promise((resolve) => setTimeout(resolve, 5));\n    }\n  }\n\n  async Get(postFetchActn: (streamArg: string) => any = (streamArg: string) => streamArg): Promise<any> {\n    if (this.Stream()) {\n      await this.WaitTillFetched(this.Source);\n      return this.Stream();\n    }\n    DynStream.CachedStreams.set(this.Source, 'fetching');\n\n    return fetch(this.Source)\n      .then((response) => {\n        if (!response.ok) {\n          throw new Error(`Invalid Stream Path. Failed to fetch ${this.CurrentType.Name} from supplied path '${this.Source}'`);\n        }\n        return response.text();\n      })\n      .then((stream) => {\n        const modifiedStream = postFetchActn(stream);\n        DynStream.CachedStreams.set(this.Source, modifiedStream);\n        return this.Stream();\n      });\n  }\n}",
    "\n\n// File: DynPlate.ts\nimport { PlateObj, PlateObjItem } from './types';\nimport { DynAlias } from './DynAlias';\nimport { DynStream } from './DynStream';\nimport { DynStreamTypes } from './types';\n\nexport class DynPlate {\n  PlateObj: PlateObj = {\n    Props: {}, RecordDepth: undefined, Template: '', Render: '',\n  };\n\n  PlateSubDyn: HTMLElement[] = [];\n\n  public PlateKey: string | undefined = undefined;\n\n  private CreatePlateObjItem = (propValue: any, recordIndex: string): PlateObjItem => ({\n    value: propValue, isArray: false, arrayValues: [], recordIndexPath: recordIndex,\n  });\n\n  RenderPlate(arrayPropIndex: number): void {\n    let plateToRender = this.PlateObj.Template;\n    Object.entries(this.PlateObj.Props).forEach(([propName, propValue]) => {\n      if (typeof propValue.value === 'object') {\n        console.warn(\"Can't bind an object to a plate\");\n      }\n      plateToRender = plateToRender.replace(\n        new RegExp(`{{${propName}}}`, 'g'),\n        propValue.isArray ? propValue.arrayValues[arrayPropIndex] : propValue.value,\n      );\n    });\n    this.PlateObj.Render = plateToRender;\n  }\n\n  BindRecordToProps(record: any, recordIndices: number[]): boolean {\n    let boundProps = false;\n    for (const propertyString in this.PlateObj.Props) {\n      boundProps = true;\n      const properties = propertyString.split('.');\n      let y = 0;\n      let result: any = record;\n      for (let i = 0; i < properties.length;) {\n        const property = properties[i];\n        if (Array.isArray(result)) {\n          result = result[recordIndices[y]];\n          y++;\n        } else {\n          result = result[property];\n          i++;\n        }\n        if (result === undefined || result === null) {\n          break; // throw and error here\n        }\n      }\n      if (Array.isArray(result)) {\n        this.PlateObj.Props[propertyString].arrayValues = result;\n        this.PlateObj.Props[propertyString].isArray = true;\n      }\n      this.PlateObj.Props[propertyString].value = result;\n    }\n    return boundProps;\n  }\n\n  async ParsePlate(htmlElement: HTMLElement): Promise<void> {\n    let plateAttributeValue = htmlElement.getAttribute('plate');\n    if (plateAttributeValue) {\n      plateAttributeValue = DynAlias.FetchOrSetAliasIfApplicable(plateAttributeValue);\n      if (plateAttributeValue[0] === '#') {\n        const template = document.querySelector(plateAttributeValue);\n        if (template) {\n          template.style.display = 'none';\n          htmlElement.innerHTML = template.innerHTML;\n        }\n      } else {\n        htmlElement.innerHTML = await new DynStream(plateAttributeValue, DynStreamTypes.PLATE).Get();\n      }\n    }\n    this.PlateKey = this.GenerateGUID();\n    await this.ParsePlateForProps(htmlElement);\n    this.PlateObj.Template = htmlElement.innerHTML;\n    htmlElement.innerHTML = '';\n  }\n\n  private async ParsePlateForProps(parentElement: HTMLElement | string): Promise<boolean> {\n    let hasDyn = false;\n    if (typeof parentElement === 'string') {\n      const container = document.createElement('div');\n      container.innerHTML = parentElement;\n      parentElement = container;\n    }\n\n    for (let i = 0; i < parentElement.childNodes.length; i++) {\n      const childHtmlNode = parentElement.childNodes[i] as HTMLElement;\n      if (childHtmlNode.nodeType === 1) {\n        if (childHtmlNode.hasAttribute('dyn')) {\n          hasDyn = true;\n          childHtmlNode.innerText.match(/{{.*\\..*}}/) ? childHtmlNode.setAttribute('recordIndex', '') : undefined;\n          childHtmlNode.setAttribute('plateindex', `${this.PlateSubDyn.length}`);\n          childHtmlNode.setAttribute('key', this.PlateKey || '');\n          this.PlateSubDyn.push(childHtmlNode.cloneNode(true) as HTMLElement);\n          childHtmlNode.innerHTML = '';\n        } else if (!await this.ParsePlateForProps(childHtmlNode) && childHtmlNode.innerText && childHtmlNode.innerText.match(/^{{([^\\}]+)}}$/)) {\n          const text = childHtmlNode.innerText.match(/\\{\\{(.*?)\\}\\}/)?.[1].trim() || '';\n          const hasExistingProp = this.PlateObj.Props[text] !== undefined;\n          this.PlateObj.Props[text] = hasExistingProp ? this.PlateObj.Props[text] : this.CreatePlateObjItem(text, childHtmlNode.getAttribute('recordIndex') || '');\n          const hasRecordDepth = this.PlateObj.RecordDepth !== undefined;\n          this.PlateObj.RecordDepth = hasRecordDepth ? this.PlateObj.RecordDepth : text;\n        }\n      }\n    }\n    return hasDyn;\n  }\n\n  GenerateGUID(): string {\n    return 'xxxxxxxx'.replace(/[xy]/g, (c) => {\n      const r = (Math.random() * 16) | 0;\n      const v = c === 'x' ? r : (r & 0x3) | 0x8;\n      return v.toString(16);\n    });\n  }\n}",
    "import { DynRules } from './DynRules';\nimport { DynAlias } from './DynAlias';\nimport { DynStream } from './DynStream';\nimport { DynStreamTypes } from './types';\n\nexport class DynRecord {\n  Record: any = undefined;\n  private Rules: DynRules;\n\n  constructor(rules: DynRules) {\n    this.Rules = rules;\n  }\n\n  async ParseRecord(htmlElement: HTMLElement): Promise<void> {\n    let postLoadAtn = (record: string): any[] => {\n      let parsedRecord = JSON.parse(record);\n      if (!Array.isArray(parsedRecord)) {\n        parsedRecord = [parsedRecord];\n      }\n      return parsedRecord;\n    };\n\n    let postAtnFilter = (record: any): any => record;\n    let preFilteredRecord: any;\n\n    if (this.Rules.CheckFuncExists(htmlElement, 'shape')) {\n      const shapeAttr = htmlElement.getAttribute('shape');\n      if (shapeAttr) {\n        postLoadAtn = (window as any)[shapeAttr];\n      }\n    }\n\n    if (this.Rules.CheckFuncExists(htmlElement, 'filter')) {\n      const filterAttr = htmlElement.getAttribute('filter');\n      if (filterAttr) {\n        postAtnFilter = (window as any)[filterAttr];\n      }\n    }\n\n    const recordAttr = htmlElement.getAttribute('record');\n    if (!recordAttr) {\n      throw new Error('Record attribute is missing');\n    }\n\n    let recordAttributeValue = DynAlias.FetchOrSetAliasIfApplicable(recordAttr);\n\n    if (this.Rules.CheckServerPath(recordAttributeValue)) {\n      preFilteredRecord = await new DynStream(recordAttributeValue, DynStreamTypes.RECORD).Get(postLoadAtn);\n    } else {\n      preFilteredRecord = (window as any)[`${recordAttributeValue}`];\n      if (!preFilteredRecord) {\n        throw new Error('A valid server location or window bound JS object was not set for the Plate');\n      }\n    }\n\n    this.Record = postAtnFilter(preFilteredRecord);\n  }\n\n  GetRecordLoopingLength(recordPath: string, recordIndices: number[]): any {\n    if (recordIndices.length === 0) {\n      return this.Record;\n    }\n\n    const properties = recordPath.split('.');\n    let result: any = this.Record;\n\n    properties.forEach((property) => {\n      if (Array.isArray(result)) {\n        if (recordIndices.length === 0) {\n          throw new Error(`No indices provided for array access in '${recordPath}'`);\n        }\n        const index = recordIndices.shift();\n        if (index !== undefined) {\n          result = result[index];\n        }\n      } else {\n        result = result[property];\n      }\n      if (result === undefined || result === null) {\n        throw new Error(`Record structure does not match with provided path '${recordPath}', indices '${recordIndices}'`);\n      }\n    });\n\n    return result;\n  }\n}",
    "export class DynBind {\n    private PerformNCalculation(number: number, nMath: string): number {\n      const nCalc = nMath.replace(/n/g, number.toString());\n      return Number(eval(nCalc));\n    }\n  \n    BindLoop(dynAtrValue: string, record: any[]): number[] {\n      const splitArray = dynAtrValue.split('...');\n      let startIndex = this.GetNValue(splitArray[0], record);\n      let endIndex = this.GetNValue(splitArray[1], record);\n      const indexes: number[] = [];\n      let reverseOrder = false;\n  \n      if (startIndex > endIndex) {\n        reverseOrder = true;\n      }\n  \n      if (startIndex > record.length || endIndex > record.length) {\n        throw new Error('Invalid index range specified for loop statement in dyn attribute. The starting or ending index ');\n      }\n      if (!reverseOrder) {\n        for (let index = startIndex; index <= endIndex; index++) {\n          indexes.push(index);\n        }\n      } else {\n        for (let index = startIndex; index >= endIndex; index--) {\n          indexes.push(index);\n        }\n      }\n      return indexes;\n    }\n  \n    BindIndex(dynAtrValue: string, dynRecord: any[]): number[] {\n      let value = this.GetNValue(dynAtrValue, dynRecord);\n  \n      if (isNaN(value) || (value < 0 || value > dynRecord.length)) {\n        throw new Error('Invalid index specified ');\n      }\n      return [value];\n    }\n  \n    private GetNValue(value: string, dynRecord: any[]): number {\n      if (value.length !== 1) {\n        return this.PerformNCalculation(dynRecord.length - 1, value);\n      } else if (value === 'n') {\n        return dynRecord.length - 1;\n      } else {\n        return Number(value);\n      }\n    }\n  }",
    "import { DynBind } from './DynBind';\n\nexport class DynRules {\n  private Bind: DynBind = new DynBind();\n  private ServerPath: RegExp = /^(.+)\\/([^\\/]+)$/;\n  private Loop: RegExp = /^(?:\\d+|n(?:-\\d+)?)\\.{3}(?:\\d+|n(?:-\\d+)?)$/;\n  private Index: RegExp = /^(?:\\d+|n(?:-\\d+)?)$/;\n  private WhiteSpace: RegExp = /^\\s*$/;\n\n  private isWhitespace(str: string = ' '): boolean {\n    return this.WhiteSpace.test(str);\n  }\n\n  CheckDynValue(dynAttributeValue: string): ((value: any, record: any[]) => number[]) | undefined {\n    switch (true) {\n      case dynAttributeValue === '':\n        return (value: any, record: any[]) => [0];\n      case this.ServerPath.test(dynAttributeValue):\n        return undefined;\n      case this.Loop.test(dynAttributeValue):\n        return this.Bind.BindLoop.bind(this.Bind);\n      case this.Index.test(dynAttributeValue):\n        return this.Bind.BindIndex.bind(this.Bind);\n      default:\n        throw Error(`Invalid value in element's Dyn attribute. Cannot be matched to a valid pattern '${dynAttributeValue}'.`);\n    }\n  }\n\n  CheckServerPath(recordAttributeValue: string): boolean {\n    return this.ServerPath.test(recordAttributeValue);\n  }\n\n  CheckDynServerAttributes(htmlElement: HTMLElement): void {\n    // Implementation needed\n  }\n\n  CheckFuncExists(htmlElement: HTMLElement, attributeToCheck: string): boolean {\n    if (!htmlElement.hasAttribute(attributeToCheck)) {\n      return false;\n    }\n    const funcName = htmlElement.getAttribute(attributeToCheck);\n    if (funcName && !window[funcName as keyof typeof window]) {\n      console.warn(`%cWARNING: Referenced function does not exist for Dyn attribute action,${funcName} will be evaluated as a bool conditional.`, 'font-weight: bold; color: Orange;');\n      return false;\n    }\n    return true;\n  }\n\n  CheckDynHasPlate(htmlElement: HTMLElement, localPlate: string): void {\n    if (htmlElement.hasAttribute('plate') && !this.isWhitespace(localPlate)) {\n      throw Error(`Plate binding conflict. Dyns with an external Plate must not have an internal Plate. Element must have an empty inner HTML '${localPlate}' `);\n    }\n\n    if (!htmlElement.hasAttribute('plate') && this.isWhitespace(localPlate)) {\n      throw Error('Empty Plate binding. Dyn has no external Plate or internal Plate. Dyn needs a Plate attribute or an inner HTML to bind too.');\n    }\n  }\n}",
    "import { DynPlate } from './DynPlate';\nimport { DynRecord } from './DynRecord';\nimport { DynRules } from './DynRules';\n\nexport class DynPair {\n  private Rules: DynRules = new DynRules();\n  private Plate: DynPlate = new DynPlate();\n  private Record: DynRecord;\n\n  constructor() {\n    this.Record = new DynRecord(this.Rules);\n  }\n\n  async CreatePair(htmlNode: HTMLElement): Promise<void> {\n    await this.Record.ParseRecord(htmlNode);\n    await this.Plate.ParsePlate(htmlNode);\n    await this.RenderPair(htmlNode);\n  }\n\n  private async RenderPair(htmlElement: HTMLElement): Promise<void> {\n    const dynAttr = htmlElement.getAttribute('dyn');\n    if (!dynAttr) {\n      throw new Error('Dyn attribute is missing');\n    }\n\n    const getIndex = this.Rules.CheckDynValue(dynAttr);\n    if (!getIndex) {\n      throw new Error('Invalid dyn attribute value');\n    }\n\n    const recordIndexAttr = htmlElement.getAttribute('recordIndex');\n    const indexToLoopOn = recordIndexAttr ? recordIndexAttr.split(',').map(Number) : [];\n    const recordLevel = this.Record.GetRecordLoopingLength(this.Plate.PlateObj.RecordDepth || '', indexToLoopOn);\n    const indexs = getIndex(dynAttr, recordLevel);\n    const parser = new DOMParser();\n\n    for (let i = 0; i < indexs.length; i++) {\n      const recordIndices = recordIndexAttr ? recordIndexAttr.split(',').map(Number) : [];\n      recordIndices.push(indexs[i]);\n\n      this.Plate.BindRecordToProps(this.Record.Record, recordIndices);\n      this.Plate.RenderPlate(indexs[i]);\n      let plateCopy = parser.parseFromString(this.Plate.PlateObj.Render, 'text/html');\n      let plateCopyElement : HTMLElement; // this needs to be thought out more? \n      plateCopyElement = plateCopy.children[0].children[1].children.length === 1 ? plateCopy.children[0].children[1].firstChild : plateCopy.children[0].children[1];\n      \n      if (plateCopyElement) {\n        plateCopyElement.id = `${this.Plate.GenerateGUID()}#${indexs[i]}`;\n        plateCopyElement.querySelectorAll('[recordIndex]').forEach((dyn) => {\n          if (dyn instanceof HTMLElement && dyn.getAttribute('key') === this.Plate.PlateKey) {\n            dyn.setAttribute('recordIndex', (dyn.getAttribute('recordIndex') || '').concat(recordIndices.join(',')));\n          }\n        });\n        htmlElement.appendChild(plateCopyElement);\n      }\n    }\n\n    for (let index = 0; index < this.Plate.PlateSubDyn.length; index++) {\n      htmlElement.querySelectorAll(`[plateindex=\"${index}\"]`).forEach((dyn) => {\n        if (dyn instanceof HTMLElement) {\n          dyn.innerHTML = this.Plate.PlateSubDyn[index].innerHTML;\n        }\n      });\n    }\n  }\n}",
    "import { DynPair } from './DynPair';\n\nexport class DynNode {\n  private ParentNode: DynNode | undefined;\n  private ChildNodes: DynNode[] = [];\n  private Pair: DynPair = new DynPair();\n  private HtmlNode: HTMLElement;\n\n  constructor(htmlNode: HTMLElement, parentNode?: DynNode) {\n    if (parentNode) {\n      parentNode.AddChild(this);\n      this.AddParent(parentNode);\n    }\n    this.HtmlNode = htmlNode;\n    if (!this.HtmlNode.getAttribute('record')) {\n      const parentScopedRecord = this.SearchUpForNearestRecord();\n      this.HtmlNode.setAttribute('record', parentScopedRecord[0]);\n      if (parentScopedRecord[1]) {\n        this.HtmlNode.setAttribute('shape', parentScopedRecord[1]);\n      }\n      if (parentScopedRecord[2]) {\n        this.HtmlNode.setAttribute('filter', parentScopedRecord[2]);\n      }\n    }\n  }\n\n  LoadNoad(): void {\n    if (this.HtmlNode.getAttribute('dyn') !== '') {\n      this.Pair.CreatePair(this.HtmlNode);\n    }\n  }\n\n  AddParent(parentDyn: DynNode): void {\n    this.ParentNode = parentDyn;\n  }\n\n  AddChild(dynNodeChild: DynNode): void {\n    dynNodeChild.AddParent(this);\n    this.ChildNodes.push(dynNodeChild);\n  }\n\n  SearchUpForNearestRecord(): [string, string | null, string | null] {\n    const isRecordEmptyOrSpaces = (attributeValue: string | null): boolean => \n      attributeValue === null || attributeValue.match(/^ *$/) !== null;\n\n    let parentNodeToSearch: DynNode | undefined = this.ParentNode;\n    \n    do {\n      if (!parentNodeToSearch) {\n        throw new Error('Dyn was not supplied a Record and no other Records were found higher up the dyn tree scope.');\n      }\n      const possibleNodeRecord = parentNodeToSearch.HtmlNode.getAttribute('record');\n      const possibleNodeShape = parentNodeToSearch.HtmlNode.getAttribute('shape');\n      const possibleNodeFilter = parentNodeToSearch.HtmlNode.getAttribute('filter');\n      \n      if (possibleNodeRecord && !isRecordEmptyOrSpaces(possibleNodeRecord)) {\n        return [possibleNodeRecord, possibleNodeShape, possibleNodeFilter];\n      }\n      parentNodeToSearch = parentNodeToSearch.ParentNode;\n    } while (true);\n  }\n}\n",
    "import { DynNode } from './DynNode';\n\nconst Trees: DynNode[] = [];\n\nasync function RecurseForDyns(htmlnode: Node, currentNode?: DynNode): Promise<void> {\n  if (htmlnode.nodeType === Node.ELEMENT_NODE && htmlnode instanceof HTMLElement) {\n    if (htmlnode.hasAttribute('dyn')) {\n      const newNode = new DynNode(htmlnode, currentNode);\n      if (currentNode === undefined) {\n        Trees.push(newNode);\n      }\n      await newNode.LoadNoad();\n      currentNode = newNode;\n    }\n  }\n  for (let i = 0; i < htmlnode.childNodes.length; i++) {\n    await RecurseForDyns(htmlnode.childNodes[i], currentNode);\n  }\n}\n\nasync function BootStrapDyn(): Promise<void> {\n  await RecurseForDyns(document.documentElement);\n}\ndocument.addEventListener('DOMContentLoaded', BootStrapDyn);"
  ],
  "mappings": "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",
  "debugId": "0AC80871532C40B664756E2164756E21",
  "names": []
}